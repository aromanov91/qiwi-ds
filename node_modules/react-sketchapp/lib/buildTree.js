"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.reactTreeToFlexTree = void 0;

var TestRenderer = require("react-test-renderer");

var yoga = require("yoga-layout");

var _Context = require("./utils/Context");

var _hasAnyDefined = require("./utils/hasAnyDefined");

var _pick = require("./utils/pick");

var _computeYogaTree = require("./jsonUtils/computeYogaTree");

var _computeTextTree = require("./jsonUtils/computeTextTree");

var _constants = require("./utils/constants");

var _zIndex = require("./utils/zIndex");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var reactTreeToFlexTree = function reactTreeToFlexTree(node, yogaNode, context) {
  var textNodes;
  var textStyle = context.getInheritedStyles();
  var style = node.props && node.props.style ? node.props.style : {};
  var type = node.type || 'text';
  var newChildren = [];

  if (type === 'svg') {
    newChildren = node.children;
  } else if (type === 'text') {
    // If current node is a Text node, add text styles to Context to pass down to
    // child nodes.
    if (node.props && node.props.style && (0, _hasAnyDefined.default)(style, _constants.INHERITABLE_FONT_STYLES)) {
      var inheritableStyles = (0, _pick.default)(style, _constants.INHERITABLE_FONT_STYLES);
      inheritableStyles.flexDirection = 'row';
      context.addInheritableStyles(inheritableStyles);
      textStyle = _objectSpread({}, context.getInheritedStyles(), inheritableStyles);
    } // Compute Text Children


    textNodes = (0, _computeTextTree.default)(node, context);
  } else if (node.children && node.children.length > 0) {
    // Recursion reverses the render stacking order
    // but that's actually fine because Sketch renders the first on top
    // Calculates zIndex order to match yoga
    var children = (0, _zIndex.default)(node.children);

    for (var index = 0; index < children.length; index += 1) {
      var childComponent = children[index];
      var childNode = yogaNode.getChild(index);
      var renderedChildComponent = reactTreeToFlexTree(childComponent, childNode, context.forChildren());
      newChildren.push(renderedChildComponent);
    }
  }

  return {
    type: type,
    style: style,
    textStyle: textStyle,
    layout: {
      left: yogaNode.getComputedLeft(),
      right: yogaNode.getComputedRight(),
      top: yogaNode.getComputedTop(),
      bottom: yogaNode.getComputedBottom(),
      width: yogaNode.getComputedWidth(),
      height: yogaNode.getComputedHeight()
    },
    props: _objectSpread({}, node.props, {
      textNodes: textNodes
    }),
    children: newChildren
  };
};

exports.reactTreeToFlexTree = reactTreeToFlexTree;

var buildTree = function buildTree(element) {
  var renderer = TestRenderer.create(element);
  var json = renderer.toJSON();
  var yogaNode = (0, _computeYogaTree.default)(json, new _Context.default());
  yogaNode.calculateLayout(undefined, undefined, yoga.DIRECTION_LTR);
  var tree = reactTreeToFlexTree(json, yogaNode, new _Context.default());
  return tree;
};

var _default = buildTree;
exports.default = _default;