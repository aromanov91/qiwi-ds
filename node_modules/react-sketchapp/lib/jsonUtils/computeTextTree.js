"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _constants = require("../utils/constants");

var walkTextTree = function walkTextTree(textTree, context, textNodes) {
  if (typeof textTree !== 'string' && !_constants.VALID_TEXT_CHILDREN_TYPES.includes(textTree.type)) {
    throw new Error("\"".concat(textTree.type, "\" is not a valid child for Text components"));
  }

  if (typeof textTree === 'string') {
    textNodes.push({
      textStyles: context.getInheritedStyles(),
      content: textTree
    });
  }

  if (textTree.children) {
    if (textTree.props && textTree.props.style) {
      context.addInheritableStyles(textTree.props.style);
    }

    for (var index = 0; index < textTree.children.length; index += 1) {
      var textComponent = textTree.children[index];
      walkTextTree(textComponent, context.forChildren(), textNodes);
    }
  }
};

var computeTextTree = function computeTextTree(node, context) {
  var textNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var children = node.children;

  if (children) {
    var childContext = context.forChildren();

    for (var index = 0; index < children.length; index += 1) {
      var textNode = children[index];

      if (typeof textNode === 'string') {
        textNodes.push({
          content: textNode,
          textStyles: childContext.getInheritedStyles()
        });
      } else if (textNode.children && textNode.children.length > 0) {
        walkTextTree(textNode, childContext, textNodes);
      }
    }
  }

  return textNodes;
};

var _default = computeTextTree;
exports.default = _default;